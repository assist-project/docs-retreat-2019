package learner;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.LinkedList;

import de.ls5.jlearn.abstractclasses.LearningException;
import de.ls5.jlearn.algorithms.angluin.Angluin;
import de.ls5.jlearn.interfaces.Alphabet;
import de.ls5.jlearn.interfaces.Automaton;
import de.ls5.jlearn.interfaces.EquivalenceOracleOutput;
import de.ls5.jlearn.interfaces.Learner;
import de.ls5.jlearn.interfaces.State;
import de.ls5.jlearn.logging.LearnLog;
import de.ls5.jlearn.logging.LogLevel;
import de.ls5.jlearn.logging.PrintStreamLoggingAppender;
import de.ls5.jlearn.shared.AlphabetImpl;
import de.ls5.jlearn.shared.SymbolImpl;
import de.ls5.jlearn.util.DotUtil;

/**
 * The Java main class for executing a learning experiment. Output generated by learning is stored in the "output" directory.
 * This output includes: hypotheses, learned model, statistics, output logs.
 */
// You should not change this insofar as it doesn't bother you. 
public class Main {
	public static String OUTPUT_DIR = "output";
	public static PrintStream  STDOUT= System.out;
	
	public static void main(String[] args) throws FileNotFoundException {
	
	    STDOUT.println("Start Learning");
	    
	    // setting up output and logging
	    File outDir = new File(OUTPUT_DIR);
	    if (!outDir.exists())
	    	outDir.mkdirs();
	    File logFile = new File(OUTPUT_DIR+File.separator+"output.txt");
	    File statsFile = new File(OUTPUT_DIR+File.separator+"statistics.txt");
	    
	    // output learned state machine as .dot and .pdf file :
	    File learnedModelDotFile = new File(OUTPUT_DIR+File.separator+"learnresult.dot");
	    File learnedModelPdfFile = new File(OUTPUT_DIR+File.separator+"learnresult.pdf");
	    
	    LearnLog.addAppender(new PrintStreamLoggingAppender(LogLevel.INFO, System.out));
		PrintStream fileStream = new PrintStream(new FileOutputStream(logFile,false));
		System.setOut(fileStream);
		StringWriter statisticsWriter = new StringWriter();
		PrintWriter statisticsPrintStream = new PrintWriter(statisticsWriter);
			
		// build membership oracles used during learning and testing (equivalence checking)
		MembershipOracle learningMemOracle = new MembershipOracle(new SutWrapper());
		EquivalenceMembershipOracle equivalenceMemOracle = new EquivalenceMembershipOracle(new SutWrapper());
		
		de.ls5.jlearn.interfaces.EquivalenceOracle eqOracle;
		
		// building the input alphabet and output alphabets
		Alphabet inputAlphabet = new AlphabetImpl();
		inputAlphabet.addSymbol(new SymbolImpl("I5"));
		inputAlphabet.addSymbol(new SymbolImpl("I10"));
		inputAlphabet.addSymbol(new SymbolImpl("IMARS"));
		inputAlphabet.addSymbol(new SymbolImpl("ISNICKERS"));

		Alphabet outputAlphabet = new AlphabetImpl();
		outputAlphabet.addSymbol(new SymbolImpl("I5"));
		outputAlphabet.addSymbol(new SymbolImpl("I10"));
		outputAlphabet.addSymbol(new SymbolImpl("IMARS"));
		outputAlphabet.addSymbol(new SymbolImpl("ISNICKERS"));
		
		Learner learner = null;
		boolean done = false;
		
		// variables for storing learning statistics
		int hypCounter = 0;
		int memQueries = 0;
		int totalMemQueries = 0;
		int totalEquivMemQueries = 0;
		long totalTimeMemQueries = 0;
		long totalTimeEquivQueries = 0;
		long start = System.currentTimeMillis();
		long starttmp = System.currentTimeMillis();
		long endtmp;
	
		while (!done) {
			eqOracle = new BasicEquivalenceOracle();

			eqOracle.setOracle(equivalenceMemOracle);
			
			// construct the learner implementing a learning algorithm (which is ObservationPack in this case)
			learner = new Angluin();
			learner.setOracle(learningMemOracle);
			learner.setAlphabet(inputAlphabet);
	
			try {
				while (!done) {
					System.out.println("starting learning");
					System.out.println("");
					System.out.flush();
					System.err.flush();
					
					//initiates an iteration of learning 
					//the learner execute membership queries until a stable hypothesis is formed
					learner.learn();
					System.out.flush();
					System.err.flush();
					System.out.println("done learning");
	
					memQueries = learningMemOracle.getNumMembQueries();
					statisticsPrintStream.println("Membership queries: " + memQueries);
					totalMemQueries += memQueries;
					endtmp = System.currentTimeMillis();
					statisticsPrintStream.println("Running time of membership queries: " + (endtmp-starttmp) + "ms.");
					totalTimeMemQueries += endtmp-starttmp;
					starttmp = System.currentTimeMillis();
					System.out.flush();
					
					//stable hypothesis after membership queries
					Automaton hyp = learner.getResult();
					DotUtil.writeDot(hyp, new File(OUTPUT_DIR+File.separator+"hypothesis" + hypCounter++ + ".dot"));
			
					System.out.println("starting equivalence query");
					System.out.flush();
					System.err.flush();
					
					//search the hypothesis for counterexamples
					EquivalenceOracleOutput o = eqOracle.findCounterExample(hyp);
					System.out.flush();
					System.err.flush();
					System.out.println("done equivalence query");
					statisticsPrintStream.println("Membership queries in Equivalence query: " + equivalenceMemOracle.getNumEquivMemQueries());
					totalEquivMemQueries +=  equivalenceMemOracle.getNumEquivMemQueries();
					endtmp = System.currentTimeMillis();
					statisticsPrintStream.println("Running time of equivalence query: " + (endtmp-starttmp) + "ms.");
					totalTimeEquivQueries += endtmp-starttmp;
					starttmp = System.currentTimeMillis();
					
					// no counter example -> learning is done
					if (o == null) {
						done = true;
						continue;
					}
					statisticsPrintStream.println("Sending CE to LearnLib.");
					System.out.println("Counter Example: " + o.getCounterExample().toString());
					System.out.flush();
					System.err.flush();
					//return counter example to the learner, so that it can use it to refine hypothesis/generate new membership queries
					learner.addCounterExample(o.getCounterExample(), o.getOracleOutput());
					System.out.flush();
					System.err.flush();
				}
			} catch (LearningException ex) {
				System.out.println("LearningException ex in Main!");
				ex.printStackTrace();
			} catch (Exception ex) {
				statisticsPrintStream.println("Exception!");
				System.out.println("Exception!");
				ex.printStackTrace();
				System.exit(-1);
			}
		}
		
		long end = System.currentTimeMillis();
		statisticsPrintStream.println("");
		statisticsPrintStream.println("");
		statisticsPrintStream.println("STATISTICS SUMMARY:");
		statisticsPrintStream.println("Total running time: " + (end-start) + "ms.");
		statisticsPrintStream.println("Total time Membership queries: " + totalTimeMemQueries);
		statisticsPrintStream.println("Total time Equivalence queries: " + totalTimeEquivQueries);
		statisticsPrintStream.println("Total Membership queries: " + totalMemQueries);
		statisticsPrintStream.println("Total Membership queries in Equivalence query: " + totalEquivMemQueries);
	
	    // final output to out.txt
		System.out.println("Done.");
		System.err.println("Successful run.");
	
		Automaton learnedModel = learner.getResult();
		State startState=learnedModel.getStart();
		
		statisticsPrintStream.println("Total states in learned Mealy machine: " + learnedModel.getAllStates().size());
		
		// output learned model with the start state highlighted
	
	    LinkedList<State> highlights=new LinkedList<State>();
		highlights.add(startState);
		BufferedWriter out=null;
		try {
			 out= new BufferedWriter(new FileWriter(learnedModelDotFile));
	
		    DotUtil.writeDot(learnedModel, out, learnedModel.getAlphabet().size(), highlights, "");
		    STDOUT.append(statisticsWriter.toString());
		    FileWriter fw = new FileWriter(statsFile);
		    fw.write(statisticsWriter.toString());
		    fw.close();
		    statisticsPrintStream.close();
		} catch (IOException ex) {
			 //Logger.getLogger(DotUtil.class.getName()).log(Level.SEVERE, null, ex);
		} finally {
			
			try {
			  out.close();
			} catch (IOException ex) {
			  //Logger.getLogger(DotUtil.class.getName()).log(Level.SEVERE, null, ex);
			}
		}
	
		// export .dot Mealy machine to pdf
		DotUtil.invokeDot(learnedModelDotFile, "pdf", learnedModelPdfFile);	
		
		
		System.err.println("Learner Finished!");
	}
}
